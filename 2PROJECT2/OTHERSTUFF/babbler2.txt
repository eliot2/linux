/*
 * File: babbler2.c
 * Author: Tad Cordle
 * Description: CMSC 421 Project 2 babbler module
 * Date: 5/12/16
 */

#define pr_fmt(fmt) "Babbler: " fmt

#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/gfp.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/kernel.h>
#include <linux/list.h>
#include <linux/miscdevice.h>
#include <linux/mm.h>
#include <linux/module.h>
#include <linux/sched.h>
#include <linux/slab.h>
#include <linux/vmalloc.h>
#include <linux/string.h>
#include <linux/cred.h>
#include <asm/uaccess.h>

struct topics_list {
	char topic[9];
	struct list_head list;
};
static struct list_head topics_head;

static char *topics_buffer;
static char *topics_ptr;
static char babble_buffer[141];

static DEFINE_SPINLOCK(main_lock);

#define BABBLENET_IRQ 6
extern void babblenet_enable(void);
extern void babblenet_disable(void);
extern const char *babblenet_get_babble(size_t * const);

/**
 * babbler_read() - callback invoked when a process reads from
 * /dev/babbler
 * @filp: process's file object that is reading from this device (ignored)
 * @ubuf: destination buffer to store babble
 * @count: number of bytes in @ubuf
 * @ppos: file offset (ignored)
 *
 * Return: number of bytes written to @ubuf, or negative on error
 */
static ssize_t babbler_read(struct file *filp, char __user * ubuf,
			    size_t count, loff_t * ppos)
{
	struct topics_list *tmp;
	struct list_head *pos, *q;

	int error = 0;
	int smallestLen =
	    (strlen(babble_buffer) < count) ? strlen(babble_buffer) : count;
	int digitCount = 0;

	kuid_t curUID = current_uid();
	long readUID;
	char *endp;

	pr_info("Read called.");

	/* If nothing to write, clear babble and return */
	if (smallestLen == 0 || strlen(topics_buffer) == 0) {
		spin_lock(&main_lock);
		memset(babble_buffer, 0, 140);
		spin_unlock(&main_lock);
		return 0;
	}

	/* If user id detected in babble, only display babble if it matches current uid */
	if (babble_buffer[0] == '@') {
		while (babble_buffer[digitCount + 1] != ' ')
			digitCount++;
		endp = babble_buffer + digitCount + 1;
		readUID = simple_strtol(babble_buffer + 1, &endp, 10);
		if (readUID != (long)curUID.val) {
			return 0;
		}
	}

	/* Search topics list for relevant topic in babble */
	spin_lock(&main_lock);
	list_for_each_safe(pos, q, &topics_head) {
		tmp = list_entry(pos, struct topics_list, list);
		pr_info("Checking if \"%s\" has \"%s\" in it", babble_buffer,
			tmp->topic);
		if (strstr(babble_buffer, tmp->topic) != NULL) {
			/* If topic found, return babble to user */
			pr_info("Found, returning to user.");
			error = copy_to_user(ubuf, babble_buffer, smallestLen);
			if (error != 0) {
				pr_info
				    ("Error copying %d bytes in babbler_read.",
				     error);
				spin_unlock(&main_lock);
				return -EFAULT;
			}

			/* Clear babble when done */
			memset(babble_buffer, 0, 140);
			spin_unlock(&main_lock);
			return smallestLen;
		}
	}
	pr_info("Nothing found!\n");

	/* If nothing of interest found, clear babble and return */
	memset(babble_buffer, 0, 140);
	spin_unlock(&main_lock);
	return 0;
}

/**
 * babbler_write() - callback invoked when a process writes to
 * /dev/babbler
 * @filp: process's file object that is writing to this device (ignored)
 * @ubuf: source buffer of bytes from user
 * @count: number of bytes in @ubuf
 * @ppos: file offset (ignored)
 *
 * Return: @count, or negative on error
 */
static ssize_t babbler_write(struct file *filp, const char __user * ubuf,
			     size_t count, loff_t * ppos)
{
	int error = 0;
	size_t newCount = count;

	pr_info("Write called.");

	/* Make sure at most 140 characters are copied */
	if (newCount > 140)
		newCount = 140;

	/* Clear topics buffer and copy */
	spin_lock(&main_lock);
	memset(babble_buffer, 0, 140);
	error = copy_from_user(babble_buffer, ubuf, newCount);
	spin_unlock(&main_lock);
	if (error != 0) {
		pr_info("Error copying %d bytes in babbler_write.", error);
		return -EFAULT;
	}
	pr_info("Babble buffer now contains \"%s\"", babble_buffer);

	return count;
}

/**
 * babbler_ctl_write() - callback invoked when a process writes to
 * /dev/babbler_ctl
 * @filp: process's file object that is writing to this device (ignored)
 * @ubuf: source buffer from user
 * @count: number of bytes in @ubuf
 * @ppos: file offset (ignored)
 *
 * Return: @count, or negative on error
 */
static ssize_t babbler_ctl_write(struct file *filp, const char __user * ubuf,
				 size_t count, loff_t * ppos)
{
	int error = 0;
	size_t newCount = count;
	struct topics_list *entry =
	    (struct topics_list *)kmalloc(sizeof(*entry), 0);

	pr_info("Topic write called.");

	/* Make sure at most 8 characters are copied */
	if (count > 8)
		newCount = 8;

	/* Return if nothing of interest to write */
	if ((char)ubuf[0] != '#')
		return count;

	/* Create list entry for new topic */
	spin_lock(&main_lock);
	memset(entry->topic, 0, 9);
	error = copy_from_user(entry->topic, ubuf, newCount);
	if (error != 0) {
		pr_info("Error copying %d bytes in babbler_ctl_write.", error);
		spin_unlock(&main_lock);
		return -EFAULT;
	}
	INIT_LIST_HEAD(&entry->list);
	list_add_tail(&entry->list, &topics_head);

	/* Append new topic to topics buffer */
	pr_info("Topics buffer is at %p", topics_buffer);
	pr_info("Topics pointer is at %p", topics_ptr);
	if ((unsigned long)topics_ptr > (unsigned long)topics_buffer) {
		memcpy(topics_ptr, "\n", 1);
		topics_ptr++;
		pr_info("Newline added!");
	}
	memcpy(topics_ptr, entry->topic, newCount);
	topics_ptr += newCount;

	pr_info("\"%s\" added to topics list.", entry->topic);
	pr_info("Topics buffer now contains:\n%s", topics_buffer);

	spin_unlock(&main_lock);

	return count;
}

/**
 * babbler_ctl_mmap() - callback invoked when a process mmap()s to
 * /dev/babbler_ctl
 * @filp: process's file object that is mapping to this device (ignored)
 * @vma: virtual memory allocation object containing mmap() request
 *
 * Return: 0 on succes, negative on error.
 */
static int babbler_mmap(struct file *filp, struct vm_area_struct *vma)
{
	unsigned long size = (unsigned long)(vma->vm_end - vma->vm_start);
	unsigned long page = vmalloc_to_pfn(topics_buffer);
	if (size > PAGE_SIZE)
		return -EIO;
	vma->vm_pgoff = 0;
	vma->vm_page_prot = PAGE_READONLY;
	if (remap_pfn_range(vma, vma->vm_start, page, size, vma->vm_page_prot))
		return -EAGAIN;

	return 0;
}

/**
 * babblenet_top() - top-half of BabbleNet ISR
 * @irq: IRQ that was invoked (ignored)
 * @cookie: Pointer to data that was passed into
 * request_threaded_irq() (ignored)
 *
 * If @irq is BABBLENET_IRQ, then wake up the bottom-half. Otherwise,
 * return IRQ_NONE.
 */
static irqreturn_t babblenet_top(int irq, void *cookie)
{
	if (irq == BABBLENET_IRQ)
		return IRQ_WAKE_THREAD;

	return IRQ_NONE;
}

/**
 * babblenet_bottom() - bottom-half to BabbleNet ISR
 * @irq: IRQ that was invoked (ignore)
 * @cookie: Pointer that was passed into request_threaded_irq()
 * (ignored)
 *
 * Fetch the incoming packet, via babblenet_get_babble(), and
 * overwrite any previously stored babble. As per babbler_write()
 * truncate the payload to the first 140 characters. Remember to add
 * appropriate spin lock calls in this function.
 *
 * Return: always IRQ_HANDLED
 */
static irqreturn_t babblenet_bottom(int irq, void *cookie)
{
	/* Get babble over network */
	size_t count = 0;
	const char *buf = babblenet_get_babble(&count);

	spin_lock(&main_lock);
	pr_info("babblenet_bottom called\n");
	pr_info("Got %s and a count of %lu", buf, (unsigned long)count);

	/* Truncate babble */
	if (count > 140)
		count = 140;

	/* Copy babble to global buffer */
	if (count > 0) {
		memset(babble_buffer, 0, 141);
		memcpy(babble_buffer, buf, count);
	}
	spin_unlock(&main_lock);

	return IRQ_HANDLED;
}

/**
 * Register file operations
 */
static const struct file_operations babbler_fops = {
	.read = babbler_read,
	.write = babbler_write
};

static const struct file_operations babbler_ctl_fops = {
	.write = babbler_ctl_write,
	.mmap = babbler_mmap
};

/**
 * Setup misc devices
 */
static struct miscdevice babbler_dev = {
	.minor = MISC_DYNAMIC_MINOR,
	.mode = 0666,
	.name = "babbler",
	.fops = &babbler_fops
};

static struct miscdevice babbler_ctl_dev = {
	.minor = MISC_DYNAMIC_MINOR,
	.mode = 0666,
	.name = "babbler_ctl",
	.fops = &babbler_ctl_fops
};

/**
 * babbler_init() - entry point into the Babbler kernel driver
 * Return: 0 on successful initialization, negative on error
 */
static int __init babbler_init(void)
{
	int retval;

	/* Make empty topics list */
	INIT_LIST_HEAD(&topics_head);

	/* Setup topics buffer */
	topics_buffer = (char *)vmalloc(PAGE_SIZE);
	if (!topics_buffer) {
		pr_err("Could not allocate memory\n");
		return -ENOMEM;
	}
	pr_info("Setting up topics buffer with size %lu", PAGE_SIZE);
	memset(topics_buffer, 0, PAGE_SIZE);
	topics_ptr = topics_buffer;

	/* Register babbler device */
	retval = misc_register(&babbler_dev);
	if (retval) {
		pr_err("Could not register babbler\n");
		goto err_vfree;
	}

	/* Register babbler control device */
	retval = misc_register(&babbler_ctl_dev);
	if (retval) {
		pr_err("Could not register babbler_ctl\n");
		goto err_deregister_babbler;
	}

	/* Setup interrupt handler */
	if (request_threaded_irq
	    (BABBLENET_IRQ, &babblenet_top, &babblenet_bottom, 0,
	     "babblenet irq", NULL)) {
		pr_err("Could not request BABBLENET_IRQ\n");
		goto err_deregister_babbler;
	}

	babblenet_enable();

	return 0;

	/* Clean up after error */
err_deregister_babbler:
	misc_deregister(&babbler_dev);
err_vfree:
	vfree(topics_buffer);
	return retval;
}

/**
 * babbler_exit() - called by kernel to clean up resources
 */
static void __exit babbler_exit(void)
{
	struct topics_list *tmp;
	struct list_head *pos, *q;

	pr_info("Exiting babbler.");

	/* Disable babblenet */
	babblenet_disable();
	free_irq(BABBLENET_IRQ, NULL);

	/* Clear list */
	pr_info("Clearning list...");
	list_for_each_safe(pos, q, &topics_head) {
		tmp = list_entry(pos, struct topics_list, list);
		pr_info("Clearning %s", tmp->topic);
		list_del(pos);
		kfree(tmp);
	}
	pr_info("Done clearing list");

	/* Deregister drivers */
	misc_deregister(&babbler_ctl_dev);
	misc_deregister(&babbler_dev);
	vfree(topics_buffer);
}

module_init(babbler_init);
module_exit(babbler_exit);

MODULE_DESCRIPTION("CS421 Babbler driver - project 2");
MODULE_LICENSE("GPL");
