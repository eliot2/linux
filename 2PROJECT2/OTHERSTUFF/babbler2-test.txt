/*
 * File: babbler2-test.c
 * Author: Tad Cordle
 * Description: CMSC 491 proj 2 test
 * Date: 5/12/16
 */

#define _BSD_SOURCE
#define _POSIX_SOURCE

#include <errno.h>
#include <error.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/user.h>

/**
 * Macro for writing to file
 *  file: the file path to write to
 *  str: the string to write to the file
 *  nextLabel: label to jump to if the write fails
 */
#define W(file, str, nextLabel) {\
	printf("Writing \"%s\" to %s.\n", str, file);\
	int wr = open(file, O_WRONLY, 0);\
	if (wr < 0)\
	{\
		test_failed++;\
		printf("Failed to open %s: %s\n", file, strerror(errno));\
		goto nextLabel;\
	}\
	int result = write(wr, str, strlen(str));\
	if (result < 0)\
	{\
		test_failed++;\
		printf("Failed to write to %s: %s\n", file, strerror(errno));\
		close(wr);\
		goto nextLabel;\
	}\
	close(wr);\
}

/**
 * Macro for reading from file
 *  file: The file path to read from
 *  expected_str: The string that should be read from the file
 *  nextLabel: The label to jump to if the read fails or an unexpected string is returned
 */
#define R(file, expected_str, nextLabel) {\
	printf("Reading from %s, expecting \"%s\"\n", file, expected_str);\
	int rd = open(file, O_RDONLY, 0);\
	if (rd < 0)\
	{\
		test_failed++;\
		printf("Failed to open %s: %s\n", file, strerror(errno));\
		goto nextLabel;\
	}\
	char buffer[512];\
	memset(buffer, 0, 512);\
	int result = read(rd, buffer, 512);\
	if (result < 0)\
	{\
		test_failed++;\
		printf("Failed to read from %s: %s\n", file, strerror(errno));\
		close(rd);\
		goto nextLabel;\
	}\
	if (strcmp(buffer, expected_str))\
	{\
		test_failed++;\
		printf("Read \"%s\" did not match expected \"%s\"\n", buffer, expected_str);\
		close(rd);\
		goto nextLabel;\
	}\
	printf("Read \"%s\", which matched expected!\n", buffer);\
	close(rd);\
}

/**
 * Macro for checking contents of /dev/babbler_ctl
 *  actual: The contents of /dev/babbler_ctl
 *  expected: The expected contents
 *  nextLabel: The label to jump to if the expected and actual contents do not match
 */
#define CHECK_CTL(actual, expected, nextLabel) {\
	printf("Testing /dev/babbler_ctl for \"%s\"\n", expected);\
	if (strcmp(actual, expected))\
	{\
		test_failed++;\
		printf("Read string \"%s\" did not match expected \"%s\"\n", actual, expected);\
		goto nextLabel;\
	}\
}

/*
 * Macro for passing a test
 *  testnum: The test number passed
 */
#define PASS(testnum) printf("Test %d passed!\n", testnum); test_passed++;

#define BABBLENET_PORT 4210

static int babblenet_socket = -1;

/**
 * Initializes the network connection to the BabbleNet server.
 *
 * If unable to connect to the server, then display an error message
 * and abort the program.
 *
 * You do not need to modify this function.
 */
static void init_babblenet_connection(void)
{
	struct addrinfo hints, *result, *p;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	int ret = getaddrinfo("localhost", "4210", &hints, &result);
	if (ret) {
		fprintf(stderr, "Could not resolve localhost: %s\n",
			gai_strerror(ret));
		exit(EXIT_FAILURE);
	}

	for (p = result; p; p = p->ai_next) {
		babblenet_socket =
		    socket(p->ai_family, p->ai_socktype, p->ai_protocol);
		if (babblenet_socket < 0) {
			continue;
		}
		if (connect(babblenet_socket, p->ai_addr, p->ai_addrlen) >= 0) {
			break;
		}
		close(babblenet_socket);
		babblenet_socket = -1;
	}

	freeaddrinfo(result);
	if (babblenet_socket < 0) {
		fprintf(stderr, "Could not connect to BabbleNet\n");
		exit(EXIT_FAILURE);
	}
}

/**
 * Send a message to the BabbleNet server.
 *
 * You do not need to modify this function.
 *
 * @param babble buffer containing babble to send
 * @param buffer_len number of bytes from @babble to send
 *
 * @return true if babble was successfully sent, false if not
 */
static bool babblenet_send(const void *babble, size_t buffer_len)
{
	if (babblenet_socket < 0) {
		fprintf(stderr, "Not connected to BabbleNet\n");
		return false;
	}

	ssize_t retval;
	do {
		retval = write(babblenet_socket, babble, buffer_len);
	} while (retval < 0 && errno == EINTR);

	if (retval < 0) {
		perror("failed to send babble");
		return false;
	} else if (retval != buffer_len) {
		fprintf(stderr, "unable to send %zu bytes (only sent %zu)\n",
			buffer_len, retval);
		return false;
	}
	return true;
}

int main(void)
{
	init_babblenet_connection();

	unsigned int test_passed = 0;
	unsigned int test_failed = 0;

	/* Create read-only mmap to /dev/babbler_ctl */
	int fd = open("/dev/babbler_ctl", O_RDONLY, 0);
	char *data = mmap(0, PAGE_SIZE, PROT_READ, MAP_SHARED, fd, 0);
	if (data == MAP_FAILED) {
		printf("mmap failed.\n");
		close(fd);
		return 0;
	}
	uid_t curUID = getuid();
	char securityTemp[100];

	printf("** Test 1: Basic case **\n");
	W("/dev/babbler_ctl", "#cs421", test2);
	W("/dev/babbler", "Test 1 babble write. #cs421", test2);
	R("/dev/babbler", "Test 1 babble write. #cs421", test2);
	PASS(1);

test2:
	printf("\n** Test 2: Making sure babble was cleared after read **\n");
	R("/dev/babbler", "", test3);
	PASS(2);

test3:
	printf("\n** Test 3: Writing topic without octothorpe **\n");
	printf("(Previous topic, #cs421, should not be overwritten)\n");
	W("/dev/babbler_ctl", "bad", test4);
	CHECK_CTL(data, "#cs421", test4);
	PASS(3);

test4:
	printf("\n** Test 4: Writing multiple topics **\n");
	W("/dev/babbler_ctl", "#1234567890", test5);
	CHECK_CTL(data, "#cs421\n#1234567", test5);
	PASS(4);

test5:
	printf("\n** Test 5: Writing empty topic **\n");
	W("/dev/babbler_ctl", "", test6);
	CHECK_CTL(data, "#cs421\n#1234567", test6);
	PASS(5);

test6:
	printf("\n** Test 6: Writing babble longer than 140 characters **\n");

	/* Write 180 characters to babbler */
	char input[181] = "#cs421 ";
	for (int i = 7; i < 179; i++)
		input[i] = 'A';
	input[179] = 'B';
	input[180] = 0;

	/* Read back, expecting the first 140 */
	char expected[141] = "#cs421 ";
	for (int i = 7; i < 140; i++)
		expected[i] = 'A';
	expected[140] = 0;
	W("/dev/babbler", input, test7);
	R("/dev/babbler", expected, test7);
	PASS(6);

test7:
	printf("\n** Test 7: Writing/reading babble with no topic **\n");
	W("/dev/babbler", "Nothing.", test8);
	R("/dev/babbler", "", test8);
	PASS(7);

test8:
	printf
	    ("\n** Test 8: Writing/reading babble with mismatched topic **\n");
	W("/dev/babbler", "#cs411", test9);
	R("/dev/babbler", "", test9);
	PASS(8);

test9:
	printf("\n** Test 9: Security test (UID match) **\n");
	printf("Current UID is %lu\n", (long)curUID);
	sprintf(securityTemp, "@%lu Security test! #1234567", (long)curUID);
	W("/dev/babbler", securityTemp, test10);
	R("/dev/babbler", securityTemp, test10);
	PASS(9);

test10:
	printf("\n** Test 10: Security test (UID mismatch) **\n");
	printf("Current UID is %lu\n", (long)curUID);
	sprintf(securityTemp, "@%lu Security test with bad UID! #1234567",
		((long)curUID) + 1);
	W("/dev/babbler", securityTemp, test11);
	R("/dev/babbler", "", test11);
	PASS(10);

test11:
	printf("\n** Test 11: Basic networking test **\n");
	if (babblenet_send("abc #cs421", 10)) {
		/* Sleep to ensure read isn't called before interrupt is handled */
		usleep(10000);
		R("/dev/babbler", "abc #cs421", test12);
		PASS(11);
	} else {
		printf("babblenet_send failed!");
		test_failed++;
		goto test12;
	}

test12:
	printf("\n** Test 12: Truncate long networked babbles **\n");

	/* Construct 180 character to babble */
	char input2[181] = "#cs421 ";
	for (int i = 7; i < 179; i++)
		input2[i] = 'A';
	input2[179] = 'B';
	input2[180] = 0;

	if (babblenet_send(input2, 180)) {
		/* Read back, expecting the first 140 */
		char expected[141] = "#cs421 ";
		for (int i = 7; i < 140; i++)
			expected[i] = 'A';
		expected[140] = 0;

		/* Sleep to ensure read isn't called before interrupt is handled */
		usleep(10000);
		R("/dev/babbler", expected, done);
		PASS(12);
	} else {
		printf("babblenet_send failed!");
		test_failed++;
		goto done;
	}

done:
	printf("\nPASSED: %d\n", test_passed);
	printf("FAILED: %d\n", test_failed);
	printf("TOTAL TESTS: %d\n\n", test_passed + test_failed);
	if (test_failed == 0)
		printf("All tests passed.\n\n");

	if (babblenet_socket >= 0) {
		close(babblenet_socket);
	}
	if (fd > 0) {
		close(fd);
	}
	return 0;
}
